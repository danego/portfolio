{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport let PositionCircleDirective = /*#__PURE__*/(() => {\n  class PositionCircleDirective {\n    constructor() {\n      this.numberOfElements = 12;\n    }\n    ngOnChanges() {\n      this.clearOldValues();\n      this.circleRadius = +this.circleSize / 2;\n      const piece = +this.pieceNumber;\n      const degrees = this.convertToAngleDegrees(piece);\n      const quadrant = this.findQuadrantNumber(degrees);\n      this.convertToAngleCssCartesian(this.convertToXAxisTriangleDegrees(degrees, quadrant), quadrant);\n      if (!this.rotationDisabled) this.generateRotateDegrees(degrees);\n    }\n    convertToAngleDegrees(piece) {\n      //piece 0 starts at 270deg / bottom\n      const pieceSeprationDegrees = 360 / this.numberOfElements;\n      let degrees = piece * pieceSeprationDegrees + 270;\n      if (degrees > 360) degrees -= 360;\n      return degrees;\n    }\n    findQuadrantNumber(degrees) {\n      let quadrant;\n      if (degrees >= 0 && degrees < 90) {\n        quadrant = 2;\n      } else if (degrees >= 90 && degrees < 180) {\n        quadrant = 1;\n      } else if (degrees >= 180 && degrees < 270) {\n        quadrant = 4;\n      } else {\n        quadrant = 3;\n      }\n      return quadrant;\n    }\n    convertToXAxisTriangleDegrees(degrees, quadrant) {\n      //triangle degrees is the angle between hypotenuse and X-axis\n      //correspond piece number to quadrant to correctly calculate triangle degrees\n      let triangleDegrees;\n      switch (quadrant) {\n        case 1:\n          triangleDegrees = 180 - degrees;\n          break;\n        case 2:\n          triangleDegrees = degrees;\n          break;\n        case 3:\n          triangleDegrees = 360 - degrees;\n          break;\n        case 4:\n          triangleDegrees = degrees - 180;\n          break;\n      }\n      ;\n      return triangleDegrees;\n    }\n    //takes the degree of triangle to X axis and the piece # to determine quadrant\n    convertToAngleCssCartesian(triangleDegrees, quadrant) {\n      //halve inputted dimensions for puzzle piece     \n      const accountForPieceX = +this.pieceWidth / 2;\n      const accountForPieceY = +this.pieceHeight / 2;\n      //we must push from opposite direction and thus must add in radius\n      const xLegPlusCircle = this.circleRadius * this.getCosFromDegrees(triangleDegrees);\n      const yLegPlusCircle = this.circleRadius * this.getSinFromDegrees(triangleDegrees);\n      const pushXAxis = Math.floor(xLegPlusCircle + this.circleRadius - accountForPieceX);\n      const pushYAxis = Math.floor(yLegPlusCircle + this.circleRadius - accountForPieceY);\n      //apply correct positioning values based on quadrant\n      if (quadrant === 1) {\n        this.left = pushXAxis.toString() + 'px';\n        this.bottom = pushYAxis.toString() + 'px';\n      } else if (quadrant === 2) {\n        this.right = pushXAxis.toString() + 'px';\n        this.bottom = pushYAxis.toString() + 'px';\n      } else if (quadrant === 3) {\n        this.right = pushXAxis.toString() + 'px';\n        this.top = pushYAxis.toString() + 'px';\n      } else {\n        this.left = pushXAxis.toString() + 'px';\n        this.top = pushYAxis.toString() + 'px';\n      }\n    }\n    //Math.cos works in radians by default\n    getCosFromDegrees(degrees) {\n      return Math.cos(degrees * Math.PI / 180);\n    }\n    getSinFromDegrees(degrees) {\n      return Math.sin(degrees * Math.PI / 180);\n    }\n    generateRotateDegrees(degrees) {\n      //backwards switch statement w/ no breaks\n      //piece (0) with largest degree value runs through all cases\n      let rotationDegrees = 0;\n      rotationDegrees = degrees - 90;\n      this.rotate = `rotate(${rotationDegrees}deg)`;\n    }\n    clearOldValues() {\n      if (this.top) this.top = null;\n      if (this.bottom) this.bottom = null;\n      if (this.left) this.left = null;\n      if (this.right) this.right = null;\n    }\n  }\n  PositionCircleDirective.ɵfac = function PositionCircleDirective_Factory(t) {\n    return new (t || PositionCircleDirective)();\n  };\n  PositionCircleDirective.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: PositionCircleDirective,\n    selectors: [[\"\", \"positionCircle\", \"\"]],\n    hostVars: 10,\n    hostBindings: function PositionCircleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"top\", ctx.top)(\"bottom\", ctx.bottom)(\"left\", ctx.left)(\"right\", ctx.right)(\"transform\", ctx.rotate);\n      }\n    },\n    inputs: {\n      pieceNumber: [\"positionCircle\", \"pieceNumber\"],\n      pieceWidth: \"pieceWidth\",\n      pieceHeight: \"pieceHeight\",\n      circleSize: \"circleSize\",\n      rotationDisabled: \"rotationDisabled\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return PositionCircleDirective;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}